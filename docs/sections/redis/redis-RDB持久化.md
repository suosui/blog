# RDB 持久化
`Redis`是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。

举个例子，图展示了一个包含三个非空数据库的Redis服务器，这三个数据库以及数据库中的键值对就是该服务器的数据库状态。
![数据库状态示例](../../assets/数据库状态示例.png)

因为`Redis`是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。为了解决这个问题，`Redis`提供了`RDB`持久化功能，这个功能可以将`Redis`在内存中的数
据库状态保存到磁盘里面，避免数据意外丢失。

`RDB`持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个`RDB`文件中。   
`RDB`持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成`RDB`文件时的数据库状态。
因为`RDB`文件是保存在硬盘里面的，所以即使`Redis`服务器进程退出，甚至运行`Redis`服务器的计算机停机，但只要`RDB`文件仍然存在，`Redis`服务器就可以用它来还原数据库状态。

## RDB文件的创建与载入

有两个`Redis`命令可以用于生成`RDB`文件，一个是`SAVE`，另一个是`BGSAVE`。  

* `SAVE`命令会阻塞`Redis`服务器进程，直到`RDB`文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求：
```shell
redis> SAVE //等待直到RDB 文件创建完毕
OK
```

* 和`SAVE`命令直接阻塞服务器进程的做法不同，`BGSAVE`命令会派生出一个子进程，然后由子进程负责创建`RDB`文件，服务器进程（父进程）继续处理命令请求：
```shell
redis> BGSAVE //派生子进程，并由子进程创建RDB 文件 Background saving started
```

创建`RDB`文件的实际工作由`rdb.c/rdbSave`函数完成，`SAVE`命令和`BGSAVE`命令会以不同的方式调用这个函数，通过以下伪代码可以明显地看出这两个命令之间的区别：
```c++
def SAVE():
# 创建RDB文件
rdbSave()
def BGSAVE():
# 创建子进程
pid = fork()
if pid == 0:
# 子进程负责创建RDB文件
rdbSave()
# 完成之后向父进程发送信号
signal_parent()
elif pid > 0:
# 父进程继续处理命令请求，并通过轮询等待子进程的信号
handle_request_and_wait_signal()
else:
# 处理出错情况
handle_fork_error()
```

* 和使用`SAVE`命令或者`BGSAVE`命令创建`RDB`文件不同，`RDB`文件的载入工作是在服务器启动时自动执行的，所以`Redis`并没有专门用于载入`RDB`文件的命令，只要`Redis`服务器在启动时检测到`RDB`文件存在，它就会自动载入`RDB`文件。

以下是`Redis`服务器启动时打印的日志记录，其中第二条日志`DB loaded from disk:...`就是服务器在成功载入`RDB`文件之后打印的：
```shell
$ redis-server
[7379] 30 Aug 21:07:01.270 # Server started, Redis version 2.9.11
[7379] 30 Aug 21:07:01.289 * DB loaded from disk: 0.018 seconds
[7379] 30 Aug 21:07:01.289 * The server is now ready to accept
```
另外值得一提的是，因为`AOF`文件的更新频率通常比`RDB`文件的更新频率高，所以:

* 如果服务器开启了`AOF`持久化功能，那么服务器会优先使用`AOF`文件来还原数据库状
态。
* 只有在`AOF`持久化功能处于关闭状态时，服务器才会使用`RDB`文件来还原数据库状态。

### SAVE 命令执行是的服务器状态

前面提到过，当`SAVE`命令执行时，`Redis`服务器会被阻塞，所以当`SAVE`命令正在执行时，客户端发送的所有命令请求都会被拒绝。   
只有在服务器执行完`SAVE`命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。

### BGSAVE 命令执行是的服务器状态

因为`BGSAVE`命令的保存工作是由子进程执行的，所以在子进程创建`RDB`文件的过程中，`Redis`服务器仍然可以继续处理客户端的命令请求，但是，在`BGSAVE`命令执行期间，服务器处理`SAVE`、`BGSAVE`、`BGREWRITEAOF`三个命令的方式会和平时有所不同。

首先，在`BGSAVE`命令执行期间，客户端发送的`SAVE`命令会被服务器拒绝，服务器禁止`SAVE`命令和`BGSAVE`命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个`rdbSave`调用，防止产生竞争条件。

其次，在`BGSAVE`命令执行期间，客户端发送的`BGSAVE`命令会被服务器拒绝，因为同时执行两个`BGSAVE`命令也会产生竞争条件。

最后，`BGREWRITEAOF`和B`GSAVE`两个命令不能同时执行:
* 如果`BGSAVE`命令正在执行，那么客户端发送的`BGREWRITEAOF`命令会被延迟到`BGSAVE`命令执行完毕之后执行。
* 如果`BGREWRITEAOF`命令正在执行，那么客户端发送的`BGSAVE`命令会被服务器拒绝。

因为`BGREWRITEAOF`和`BGSAVE`两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一个好主意。

### RDB文件文件载入时的服务器状态

服务器在载入`RDB`文件期间，会一直处于阻塞状态，直到载入工作完成为止。

## 自动间隔性保存

## RDB文件结构
