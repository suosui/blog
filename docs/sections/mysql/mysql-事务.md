# 概念 
把需要保证原子性、隔离性、一致性和持久性的(`ACID`)一个或多个数据库操作称之为一个事务（`transaction`）。

### 事务的状态

1. 活动的（`active`）  
事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。

2. 部分提交的（`partially committed`）  
当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。

3. 失败的（`failed`）  
当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。

4. 中止的（`aborted`）  
如果事务执行了半截而变为失败的状态，比如我们前边唠叨的狗哥向猫爷转账的事务，当狗哥账户的钱被扣除，但是猫爷账户的钱没有增加时遇到了错误，从而当前事务处在了失败的状态，那么就需要把已经修改的狗哥账户余额调整为未转账之前的金额，换句话说，就是要撤销失败事务对当前数据库造成的影响。书面一点的话，我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。

5. 提交的（`committed`）  
当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。

### 语法

#### 开启事务
```shell
BEGIN [WORK]; or START TRANSACTION;
```
BEGIN 和 START TRANSACTION 的区别是可以在`START TRANSACTION`语句后边跟随几个修饰符;
1. `READ ONLY`：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。
2. `READ WRITE`：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。
3. `WITH CONSISTENT SNAPSHOT`：启动一致性读。

比如我们想开启一个只读事务的话，直接把READ ONLY这个修饰符加在START TRANSACTION语句后边就好，比如这样：
```shell
START TRANSACTION READ ONLY;
```

如果我们想在`START TRANSACTION`后边跟随多个修饰符的话，可以使用逗号将修饰符分开，比如开启一个只读事务和一致性读，就可以这样写：
```shell
START TRANSACTION READ ONLY, WITH CONSISTENT SNAPSHOT;
```

或者开启一个读写事务和一致性读，就可以这样写：
```shell
START TRANSACTION READ WRITE, WITH CONSISTENT SNAPSHOT;
```
不过这里需要大家注意的一点是，`READ ONLY`和`READ WRITE`是用来设置所谓的事务访问模式的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为只读的也设置为读写的，所以我们不能同时把`READ ONLY`和`READ WRITE`放到`START TRANSACTION`语句后边。另外，如果我们不显式指定事务的访问模式，那么该事务的访问模式就是**读写模式**。

#### 提交事务
```shell
COMMIT [WORK]
```

#### 手动终止事务
```shell
ROLLBACK [WORK]
```

#### 自动提交
MySQL中有一个系统变量`autocommit`：

```shell
mysql> SHOW VARIABLES LIKE 'autocommit';  
+---------------+-------+  
| Variable_name | Value |    
+---------------+-------+  
| autocommit    | ON    |  
+---------------+-------+  
1 row in set (0.01 sec)
```
可以看到它的默认值为`ON`，也就是说默认情况下，如果我们不显式的使用`START TRANSACTION`或者`BEGIN`语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的自动提交。

#### 隐式提交
当我们使用`START TRANSACTION`或者`BEGIN`语句开启了一个事务，或者把系统变量`autocommit`的值设置为`OFF`时，事务就不会进行自动提交，但是如果我们输入了某些语句之后就会悄悄的提交掉，就像我们输入了`COMMIT`语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为隐式提交，这些会导致事务隐式提交的语句包括：
* 定义或修改数据库对象的数据定义语言（Data definition language，缩写为：DDL）
* 隐式使用或修改mysql数据库中的表
* 事务控制或关于锁定的语句
* 加载数据的语句
* 关于MySQL复制的一些语句

#### 保存点
如果你开启了一个事务，并且已经敲了很多语句，忽然发现上一条语句有点问题，你只好使用`ROLLBACK`语句来让数据库状态恢复到事务执行之前的样子，然后一切从头再来，总有一种一夜回到解放前的感觉。所以设计数据库的大叔们提出了一个保存点（英文：`savepoint`）的概念，就是在事务对应的数据库语句中打几个点，我们在调用`ROLLBACK`语句时可以指定会滚到哪个点，而不是回到最初的原点。定义保存点的语法如下：
```shell 
SAVEPOINT 保存点名称;
```
当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词`WORK`和`SAVEPOINT`是可有可无的）：
```shell
ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;
```
不过如果ROLLBACK语句后边不跟随保存点名称的话，会直接回滚到事务执行之前的状态。

如果我们想删除某个保存点，可以使用这个语句：
```shell
RELEASE SAVEPOINT 保存点名称;
```