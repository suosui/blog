# 介绍
在`Redis`中，用户可以通过执行`SLAVEOF`命令或者设置`slaveof`选项，让一个服务器去复制（`replicate`）另一个服务器，我们称呼被复制的服务器为主服务器（`master`），而对主服务器进行复制的服务器则被称为从服务器（`slave`）。

## 旧版复制功能的实现
Redis的复制功能分为同步(`sync`)和命令传播(`command propagate`)两个操作:
* 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
* 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

### 同步
当客户端向从服务器发送`SLAVEOF`命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。从服务器对主服务器的同步操作需要通过向主服务器发送`SYNC`命令来完成，以下是`SYNC`命令的执行步骤：  
1. 从服务器向主服务器发送`SYNC`命令。  
2. 收到`SYNC`命令的主服务器执行`BGSAVE`命令，在后台生成一个`RDB`文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
3. 当主服务器的`BGSAVE`命令执行完毕时，主服务器会将`BGSAVE`命令生成的`RDB`文件发送给从服务器，从服务器接收并载入这个`RDB`文件，将自己的数据库状态更新至主服务器执行`BGSAVE`命令时的数据库状态。
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

下图展示了一个主从复制的例子：
 <table>
　　　        <thead>
　　　            <tr>
　　　                <th>时间</th>
　　　                <th>主服务器</th>
                     <th>从服务器</th>
　　　            </tr>
　　　        </thead>
　　　        <tbody>
　　　            <tr>
　　　                <td>T0</td>
　　　                <td>服务器启动</td>
                     <td>服务器启动</td>
　　　            </tr>
　　　            <tr>
　　　                <td>T1</td>
　　　                <td>执行SET k1 v1</td>
                     <td></td>
　　　            </tr>
　　　            <tr>
　　　              　<td>T2</td>
　　　                <td>执行SET k2 v2</td>
                     <td></td>
　　　            </tr>
　　　            <tr>
　　　              　<td>T3</td>
　　　                <td>执行SET k3 v3</td>
                     <td></td>
　　　            </tr>
　　　            <tr>
　　　                 <td>T4</td>
　　　                <td></td>
                     <td>向服务器发送SYNC命令</td>
　　　            </tr>
                    <tr>
　　　                 <td>T5</td>
　　　                <td>接收到从服务器发来的SYNC命令，执行BGSAVE命令，创建包含键K1,k2,k3的RDB文件，并使用缓冲区记录接下来执行的所有写命令</td>
                     <td></td>
　　　            </tr>
                   <tr>
　　　                 <td>T6</td>
　　　                <td>执行SET k4 v4, 并将这个命令记录到缓冲区里面</td>
                     <td></td>
　　　            </tr>
                   <tr>
　　　                 <td>T7</td>
　　　                <td>执行SET k5 v5, 并将这个命令记录到缓冲区里面</td>
                     <td></td>
　　　            </tr>
                   <tr>
　　　                 <td>T8</td>
　　　                <td>BGSAVE命令执行完毕，向服务器发送RDB文件</td>
                     <td></td>
　　　            </tr>
                   <tr>
　　　                 <td>T9</td>
　　　                <td></td>
                     <td>接收并载入主服务器发来的RDB文件，获得K1,K2,K3三个键</td>
　　　            </tr>
                   <tr>
　　　                 <td>T10</td>
　　　                <td>向从服务器发送缓冲区中保存的写命令SET K4 v4和SET k5 v5</td>
                     <td></td>
　　　            </tr>
                   <tr>
　　　                 <td>T11</td>
　　　                <td></td>
                     <td>接收并执行主服务器发来的两个SET命令，得到K4和K5两个键</td>
　　　            </tr>
                   <tr>
　　　                 <td>T12</td>
　　　                <td>同步完成，现在主从服务器两者的数据库都包含了键K1,K2,K3,K4和K5</td>
                     <td>同步完成，现在主从服务器两者的数据库都包含了键K1,K2,K3,K4和K5</td>
　　　            </tr>
 　　　       </tbody>
　　　    </table>
&emsp;通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的
编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对
象设置不同的编码，从而优化对象在某一场景下的效率。    

### 命令传播
在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。  
为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。

## 旧版复制功能的缺陷
在 `Redis` 中，从服务器对主服务器的复制可以分为以下两种情况：
* 初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。
* 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。  

对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。

下图展示了 从服务器在断线之后重新复制主服务器的例子：
 <table>
　　　        <thead>
　　　            <tr>
　　　                <th>时间</th>
　　　                <th>主服务器</th>
                     <th>从服务器</th>
　　　            </tr>
　　　        </thead>
　　　        <tbody>
　　　            <tr>
　　　                <td>T0</td>
　　　                <td>主从服务器完成同步</td>
                     <td>主从服务器完成同步</td>
　　　            </tr>
　　　            <tr>
　　　                <td>T1</td>
　　　                <td>执行并传播 SET k1 v1</td>
                     <td>执行主服务器传来的 SET k1 v1</td>
　　　            </tr>
　　　            <tr>
　　　              　<td>T2</td>
                     <td>执行并传播 SET k2 v12</td>
                     <td>执行主服务器传来的 SET k2 v2</td>
　　　            </tr>
　　            <tr>
　　　               <td>...</td>
                    <td>...</td>
                    <td>...</td>
　　　            </tr>
　　　            <tr>
　　　              　<td>T10085</td>
　　　                <td>执行并传播 SET k10085 v10085</td>
                     <td>执行主服务器传来的SET k10085 v10085</td>
　　　            </tr>
　　　            <tr>
　　　                <td>T10086</td>
　　　                <td>执行并传播SET k10086 v10086</td>
                     <td>执行主服务器传来的SET k10086 v10086</td>
　　　            </tr>
                    <tr>
　　　                <td>T10087</td>
　　　                <td>主从服务器连接断开</td>
                     <td>主从服务器连接断开</td>
　　　            </tr>
                   <tr>
　　　                <td>T10088</td>
　　　                <td>执行 SET k10087 v10087</td>
                     <td>断线中，尝试重新连接主服务器</td>
　　　            </tr>
                   <tr>
　　　                <td>T10089</td>
　　　                <td>执行 SET k10088 v10088</td>
                     <td>断线中，尝试重新连接主服务器</td>
　　　            </tr>
                   <tr>
　　　　               <td>T10091</td>
　　　                <td>主从服务器重新连接</td>
                     <td>主从服务器重新连接</td>
　　　            </tr>
                   <tr>
　　　　               <td>T10092</td>
　　　                <td></td>
                     <td>向主服务器发送SYNC命令</td>
　　　            </tr>
                   <tr>
　　　                 <td>T10093</td>
　　　                <td>接收到从服务器发送来的SYNC命令，执行BGSAVE命令，创建包含键k1至键k10089的RDB文件, 并使用缓冲区记录接下来执行的所有写命令</td>
                     <td></td>
　　　            </tr>
                   <tr>
　　　                 <td>T10094</td>
　　　                <td>BGSAVE命令执行完毕，向从服务器发送RDB文件</td>
                     <td></td>
　　　            </tr>
                   <tr>
　　　                 <td>T10095</td>
　　　                <td></td>
                     <td>接收并载入主服务器发来的RDB文件，获得键看k1至键10089</td>
　　　            </tr>
                <tr>
　　　                 <td>T10096</td>
　　　                <td>因为在BGSAVE命令执行期间，主服务器没有执行任何写命令，所以跳过发送缓冲区包含的写命令这一步</td>
                     <td></td>
　　　            </tr>
                <tr>
　　　                 <td>T10097</td>
　　　                <td>主从服务器再次完成同步</td>
                     <td>主从服务器再次完成同步</td>
　　　            </tr>
 　　　       </tbody>
　　　    </table>

在时间`T10091`，从服务器终于重新连接上主服务器，因为这时主从服务器的状态已经不再一致，所以从服务器将向主服务器发送`SYNC`命令，而主服务器会将包含键k1至键k10089的
`RDB`文件发送给从服务器，从服务器通过接收和载入这个`RDB`文件来将自己的数据库更新至主服务器数据库当前所处的状态。  
虽然再次发送`SYNC`命令可以让主从服务器重新回到一致状态，但如果我们仔细研究这个断线重复制过程，就会发现传送`RDB`文件这一步实际上并不是非做不可的：   
* 主从服务器在时间`T0`至时间T`10086`中一直处于一致状态，这两个服务器保存的数据大部分都是相同的。
* 从服务器想要将自己更新至主服务器当前所处的状态，真正需要的是主从服务器连接中断期间，主服务器新添加的`k10087`、`k10088`、`k10089`三个键的数据。
* 可惜的是，旧版复制功能并没有利用以上列举的两点条件，而是继续让主服务器生成并向从服务器发送包含键`k1`至键k`10089`的`RDB`文件，但实际上`RDB`文件包含的键k1至键k10086
的数据对于从服务器来说都是不必要的。

上面给出的例子可能有一点理想化，因为在主从服务器断线期间，主服务器执行的写命令可能会有成百上千个之多，而不仅仅是两三个写命令。但总的来说，主从服务器断开的时
间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数
据，却要让主从服务器重新执行一次`SYNC`命令，这种做法无疑是非常低效的。

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`SYNC命令是一个非常耗费资源的操作`

每次执行SYNC命令，主从服务器需要执行以下动作：

1. 主服务器需要执行`BGSAVE`命令来生成`RDB`文件，这个生成操作会耗费主服务器大量的`CPU`、内存和磁盘`I/O`资源。
2. 主服务器需要将自己生成的`RDB`文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影
响。
3. 接收到`RDB`文件的从服务器需要载入主服务器发来的`RDB`文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。

因为`SYNC`命令是一个如此耗费资源的操作，所以`Redis`有必要保证在真正有需要时才执行`SYNC`命令。