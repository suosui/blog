# 概念
`Mysql` 通常把需要更改的页缓存到 `Buffer Pool` 再进行访问，就是先把页缓存到内从里面，再访问。为了保证`持久性`需要把修改的页从内存写入磁盘。但是要把整个页写入磁盘有两个问题：  
1. 刷新一个完整的数据页太浪费了。  
有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。

2. 随机IO刷起来比较慢。  
一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。

这时我们可以把更改的行为作为日志的格式写入磁盘，也就是redo日志。有两点好处：  
1. redo日志占用的空间非常小  
存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的，关于redo日志的格式我们稍后会详细唠叨，现在只要知道一条redo日志占用的空间不是很大就好了。

2. redo日志是顺序写入磁盘的  
在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。


# redo日志格式
绝大部分类型的redo日志都有下边这种通用的结构：
```
 ┌──────┐─────────┐─────────────┐─────────────────────┐ 
 | type | spaceID | page number |         data        |
 └──────┘─────────┘─────────────┘─────────────────────┘ 
                  redo 日志通用结构
```

各个部分的详细释义如下：

* type：该条redo日志的类型。  
在MySQL 5.7.21这个版本中，redo日志有53种不同的类型，稍后会详细介绍不同类型的redo日志。

* space ID：表空间ID。

* page number：页号。

* data：该条redo日志的具体内容。

# redo日志的大小
为了更好的进行系统崩溃恢复，他们把通过mtr生成的redo日志都放在了大小为512字节的页中。为了和我们前边提到的表空间中的页做区别，我们这里把用来存储redo日志的页称为block（你心里清楚页和block的意思其实差不多就行了）。一个redo log block的示意图如下：
```
         0  ┌───────────────────────┐
            │   log block header    │
       12B  |───────────────────────|        
            │                       │         
            |                       |  
            │   lock block body     │  
            |                       | 
      508B  |───────────────────────|
            │   lock block trailer  │         
      512B  └───────────────────────┘         
                redo log block 结构
```
真正的redo日志都是存储到占用496字节大小的log block body中。

# 乐观插入和悲观插入

* 乐观插入是指要插入的页空间充足，只生成一条redo日志。
* 悲观插入是指要插入的页空间不足，需要页分裂，导致生成多条redo日志。

# redo日志缓冲区
 
我们前边说过，为了解决磁盘速度过慢的问题而引入了Buffer Pool。同理，写入redo日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为redo log buffer的连续内存空间，翻译成中文就是redo日志缓冲区，我们也可以简称为log buffer。这片内存空间被划分成若干个连续的redo log block。  
我们可以通过启动参数innodb_log_buffer_size来指定log buffer的大小，在MySQL 5.7.21这个版本中，该启动参数的默认值为16MB。


# redo日志刷盘时机

* log buffer空间不足时  
log buffer的大小是有限的（通过系统变量innodb_log_buffer_size指定），如果不停的往这个有限大小的log buffer里塞入日志，很快它就会被填满。设计InnoDB的大叔认为如果当前写入log buffer的redo日志量已经占满了log buffer总容量的大约一半左右，就需要把这些日志刷新到磁盘上。

* 事务提交时  
我们前边说过之所以使用redo日志主要是因为它占用的空间少，还是顺序写，在事务提交时可以不把修改过的Buffer Pool页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的redo日志刷新到磁盘。

* 将某个脏页刷新到磁盘前，会保证先将该脏页对应的 redo 日志刷新到磁盘中（再一次 强调，redo 日志是顺序刷新的，所以在将某个脏页对应的 redo 日志从 redo log buffer 刷新到磁盘时，也会保证将在其之前产生的 redo 日志也刷新到磁盘）。

* 后台线程不停的刷刷刷  
后台有一个线程，大约每秒都会刷新一次log buffer中的redo日志到磁盘。

* 正常关闭服务器时

* 做所谓的checkpoint时（我们现在没介绍过checkpoint的概念，稍后会仔细唠叨，稍安勿躁）

* 其他的一些情况...