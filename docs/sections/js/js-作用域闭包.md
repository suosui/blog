- [闭包](#闭包)
  * [定义](#定义)


# 闭包

## 定义
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

下面我们来看一段代码，清晰地展示了`闭包`：

```javascript
function foo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    return bar;
}
var baz = foo();
```
 `foo()` 执行后，通常会期待 `foo()` 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 `foo()` 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 `bar()` 本身在使用。  
 &emsp;拜 `bar()` 所声明的位置所赐，它拥有涵盖 `foo()` 内部作用域的闭包，使得该作用域能够一直存活，以供 `bar()` 在之后任何时间进行引用。   
 `bar()` 依然持有对该作用域的引用，而这个引用就叫作`闭包`。

 当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。
 ```javascript
 function foo() {
    var a = 2;
    function baz() {
        console.log(a); // 2
    }
    bar(baz);
}
function bar(fn) {
    fn();
}
 ```  
把内部函数 `baz` 传递给 `bar`，当调用这个内部函数时（现在叫作 `fn`），它涵盖的 `foo()` 内部作用域的闭包就可以观察到了，因为它能够访问 `a`。   
传递函数当然也可以是间接的。
```javascript
var fn;
function foo() {
    var a = 2;
    function baz() {
        console.log(a);
    }
    fn = baz; // 将 baz 分配给全局变量
}
function bar() {
    fn(); 
}
foo();
bar(); // 2
```
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。