## 第七,八章.进程调度

:question: ***cpu性能指标有哪些***  
:key:   
* 周转时间 [^1]
* 响应时间 [^2]

:question: ***针对转转时间：进程调度算法有哪些***  
:key:
* 先进先出(FIFO)   
&nbsp;&nbsp;&nbsp;&nbsp;优点: 简单。  
&nbsp;&nbsp;&nbsp;&nbsp;缺点: 长作业等待时间长。
* 最短任务优先（SJF）非抢占式   
&nbsp;&nbsp;&nbsp;&nbsp;优点: 最小化平均周转时间。   
&nbsp;&nbsp;&nbsp;&nbsp;缺点：饥饿。
* 抢占式最短作业优先（PSJF）抢占式   

:question: ***针对响应时间：进程调度算法有哪些***   
:key:
* 轮转调度（RR）[^3]  
&nbsp;&nbsp;&nbsp;&nbsp;优点: 响应时间短。  
&nbsp;&nbsp;&nbsp;&nbsp;缺点: 周转时间长。
* 多级反馈队列调度（MFQS）[^4]  
&nbsp;&nbsp;基本规则:[^5]  
&nbsp;&nbsp;&nbsp;&nbsp;规则1：如果A的优先级 > B的优先级，运行A（不运行B）。    
&nbsp;&nbsp;&nbsp;&nbsp;规则2：如果A的优先级 = B的优先级，轮转运行A和B。  
&nbsp;&nbsp;&nbsp;&nbsp;规则3：工作进入系统时，放在最高优先级（最上层队列）。  
&nbsp;&nbsp;&nbsp;&nbsp;规则4.1：工作用完整个时间片后，降低其优先级（移入下一个队列）。  
&nbsp;&nbsp;&nbsp;&nbsp;规则4.2：如果工作在其时间片以内主动释放CPU，则优先级不变。  


[^1]: T周转时间= T完成时间−T到达时间  
[^2]: T响应时间= T首次运行−T到达时间  
[^3]: 时间片轮转调度算法（RR）： 每个进程分配一个时间片，时间片用完后，进程被挂起，放到就绪队列的末尾    
[^4]: MLFQ中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ总是优先执行较高优先级的工作（即在较高级队列中的工作）。
[^5]: MLFQ 调度策略的关键在于如何设置优先级。MLFQ没有为每个工作指定不变的优先情绪而已，而是根据观察到的行为调整它的优先级。例如，如果一个工作不断放弃CPU去等待键盘输入，这是交互型进程的可能行为，MLFQ因此会让它保持高优先级。相反，如果一个工作长时间地占用CPU，MLFQ会降低其优先级。通过这种方式，MLFQ在进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。


 