## 第六章 机制：受限直接执行

:question: ***如何高效、可控地虚拟化CPU？***    
:key: 答:受限直接执行。  

:question: ***如何受限直接执行?***    
:key: 答: 引入用户模式， 用户模式下运行的代码会受到限制,不能直接访问磁盘、网络资源。与用户模式不同，内核模式下可以做任何操作，比如：访问磁盘/网络。  

:question: ***怎么切换到内核模式？***  
:key: 答: 用户程序必须执行特殊的陷阱（trap）指令。  

:question: ***怎么切换到用户模式？***  
:key: 答:操作系统调用一个特殊的陷阱返回（return-from-trap）指令，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。  

:question: ***陷阱表(trap table)是什么？***  
:key: 答:当用户模式切换到内核模式时，系统通过陷阱表（trap table）执行去执行相应的代码。换句话说，trap table就是一个map。根据不同情况执行系统调用。


:question: ***举例受限执行***   
:key: 答:
 <table>
    　　　 <thead>
        　　　 <tr>
            　　　 <th>操作系统@启动(内核模式)</th>
            　　　 <th>硬件</th>
            　　　 <th></th>
            　　　 </tr>
        　　　 </thead>
    　　　 <tbody>
        　　　 <tr>
            　　　 <td>初始化陷阱表</td>
            　　　 <td></td>
            　　　 <td></td>
            　　　 </tr>
        　　　 <tr>
            　　　 <td></td>
            　　　 <td>记住系统调用处理程序的地址</td>
            　　　 <td></td>
            　　　 </tr>
        　　　 <tr>
            　　　 <td>操作系统@运行(内核模式)</td>
            　　　 <td>硬件</td>
            　　　 <td>程序(应用模式)</td>
            　　　 </tr>
        　　　 <tr>
            　　　 <td>在进程列表上创建条目 <br />
                为程序分配内存<br />
                将程序加载到内存<br />
                根据argv设置程序栈<br />
                从陷阱返回<br />
            </td>
            　　　 <td></td>
            　　　 <td></td>
            　　　 </tr>
        　　　 <tr>
            　　　 <td></td>
            　　　 <td>从内存栈恢复寄存器<br />
                转向用户模式<br />
                跳转main<br />
            </td>
            <td></td>
            　　　
        </tr>
        　　　 <tr>
            　　　 <td></td>
            　　　 <td></td>
            　　　 <td>
                运行main<br />
                ....<br />
                调用系统调用<br />
                陷入操作系统<br />
            </td>
            　　　 </tr>
        <tr>
            <td></td>
            <td>
                将寄存器保存到内核栈<br />
                跳转到内核模式<br />
                跳转到陷阱处理程序<br />
            </td>
            <td></td>
        </tr>
        <tr>
            <td>
                处理陷阱</br>
                做系统调用</br>
                从陷阱返回</br>
            </td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>
                从内核栈恢复寄存器</br>
                转向用户模式</br>
                跳到陷阱之后的程序计数器</br>
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td>
                ....从main返回</br>
                陷入(通过exit())</br>
            </td>
        </tr>
        <tr>
            <td>
                释放进程的内</br>
                将进程列表清除</br>
            </td>
             <td></td>
            <td></td>
        </tr>
    </tbody>
</table>   [^1]

[^1]: LDE协议有两个阶段。第一个阶段（在系统引导时），内核初始化陷阱表，并且CPU记住它的位置以供随后使用。内核通过特权指令来执行此操作（所有特权指令均以粗体突出显示）。第二个阶段（运行进程时），在使用从陷阱返回指令开始执行进程之前，内核设置了一些内容（例如，在进程列表中分配一个节点，分配内存）。这会将CPU切换到用户模式并开始运行该进程。当进程希望发出系统调用时，它会重新陷入操作系统，然后再次通过从陷阱返回，将控制权还给进程。该进程然后完成它的工作，并从main()返回。这通常会返回到一些存根代码，它将正确退出该程序（例如，通过调用exit()系统调用，这将陷入OS中）。此时，OS清理干净，任务完成了