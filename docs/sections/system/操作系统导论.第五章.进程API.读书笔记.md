## 第五章 进程API

***进程API有哪些***:question:       
:key: 答:   
```
    (1) fork()
    (2) wait()
    (3) exec()
```  
***fork()做了什么***:question:      
:key: 答: 拷贝了父进程。有自己的地址空间（写时复制）。  

***wait()做了什么***:question:    
:key: 答: 父进程如果想等待子进程执行完毕。则调用wait。  

***exec()做了什么***:question:  
:key: 答: fork是执行相同的程序时调用，exec是调用执行不同的程序。exec没有创建新进程，而是直接替换当前的程序(覆盖代码，静态数据。推，栈以及其他空间也会被重新初始化)。[^1]  

[^1]: fork() 和 exec() 是两个不同的系统调用，它们在进程管理和程序执行方面有着不同的作用。我们先来区分这两者的功能：
fork()：fork() 系统调用创建一个与调用它的进程（父进程）几乎完全相同的新进程（子进程）。子进程是父进程的副本，拥有相同的代码、数据、文件描述符等。唯一的区别是父进程和子进程的进程 ID（PID）不同。在 fork() 调用之后，父进程和子进程从调用点开始并行执行。
exec()：exec() 系统调用用于在当前进程的上下文中执行一个新程序。它会替换当前进程的代码、数据、堆栈等，并开始执行新程序。exec() 调用成功后，原来的进程就不存在了，新程序从其入口点开始执行。需要注意的是，exec() 系列函数有多种形式，如 execl()、execv()、execle()、execve() 等，但它们的核心功能是相同的。
将 fork() 和 exec() 分离的做法在构建 UNIX shell 时非常有用，原因有以下几点：
控制进程创建：通过分离 fork() 和 exec()，Shell 可以在创建新进程后、执行新程序前进行一些操作。这使得 Shell 可以管理子进程并在执行新程序前对其环境进行修改。
环境修改：在 fork() 和 exec() 之间，Shell 可以修改子进程的环境。例如，改变工作目录、设置或修改环境变量等。这使得用户可以自定义子进程的执行环境，影响新程序的行为。
I/O 重定向：Shell 可以在执行新程序之前修改子进程的文件描述符，实现 I/O 重定向。这使得用户可以将程序的输出重定向到文件或其他设备，或者从文件或其他设备读取输入。这在日志记录、数据处理等场景中非常有用。
管道：Shell 可以在子进程之间创建管道，使一个进程的输出成为另一个进程的输入。这允许用户将多个命令链接在一起，形成命令管道，从而实现复杂的数据处理任务。管道是 UNIX 哲学的核心概念之一，即“将简单的工具连接起来完成复杂的任务”。
综上所述，将 fork() 和 exec() 分离的做法使得 Shell 在创建新进程并执行新程序时具有更大的灵活性，可以对子进程进行更精细的控制，并实现诸如 I/O 重定向和管道等高级功能。这种分离的设计使得 UNIX shell 成为一个强大且灵活的工具，允许用户通过简单的命令组合和环境设置来实现复杂的任务。
例如，假设用户想要找出一个大型文本文件中包含特定关键字的行数。他们可以使用 grep 命令来过滤包含关键字的行，然后通过管道将 grep 的输出传递给 wc 命令以计算行数。这个命令可能类似于：
grep "keyword" largefile.txt | wc -l
在这个示例中，shell 首先使用 fork() 创建两个子进程，一个用于执行 grep 命令，另一个用于执行 wc 命令。然后，shell 在两个子进程之间创建一个管道，并将 grep 的输出文件描述符重定向到管道的写端，将 wc 的输入文件描述符重定向到管道的读端。接下来，shell 使用 exec() 在这两个子进程中分别执行 grep 和 wc 程序。这样，grep 的输出就直接作为 wc 的输入，用户可以方便地得到结果。
这个示例展示了通过分离 fork() 和 exec() 实现的灵活性，以及 UNIX shell 如何通过简单命令的组合实现复杂任务。这种设计使得 shell 和操作系统之间的交互更加高效，同时也使得用户可以灵活地控制进程行为。