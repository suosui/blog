## 第六章 机制：受限直接执行

:question: ***如何高效、可控地虚拟化CPU***   
:key: 受限直接执行。  

:question: ***如何受限直接执行***    
:key: 引入用户模式， 用户模式下运行的代码会受到限制,不能直接访问磁盘、网络资源。与用户模式不同，内核模式下可以做任何操作，比如：访问磁盘/网络。  

:question:***怎么切换到内核模式***   
:key: 用户程序必须执行特殊的陷阱（trap）指令。  

:question:***怎么切换到用户模式***    
:key: 操作系统调用一个特殊的陷阱返回（return-from-trap）指令，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。  

:question:***陷阱表(trap table)是什么***   
:key: 当用户模式切换到内核模式时，系统通过陷阱表（trap table）执行去执行相应的代码。换句话说，trap table就是一个map。根据不同情况执行系统调用。

:question:***举例受限执行***   
:key: [^1]   
<table>
    <thead>
        <tr>
            <th>操作系统@启动(内核模式)</th>
            <th>硬件</th>
            <th></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>初始化陷阱表</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>记住系统调用处理程序的地址</td>
            <td></td>
        </tr>
        <tr>
            <td>操作系统@运行(内核模式)</td>
            <td>硬件</td>
            <td>程序(应用模式)</td>
        </tr>
        <tr>
            <td>在进程列表上创建条目 <br />
                为程序分配内存<br />
                将程序加载到内存<br />
                根据argv设置程序栈<br />
                从陷阱返回<br />
            </td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>从内存栈恢复寄存器<br />
                转向用户模式<br />
                跳转main<br />
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td>
                运行main<br />
                ....<br />
                调用系统调用<br />
                陷入操作系统<br />
            </td>
        </tr>
        <tr>
            <td></td>
            <td>
                将寄存器保存到内核栈<br />
                跳转到内核模式<br />
                跳转到陷阱处理程序<br />
            </td>
            <td></td>
        </tr>
        <tr>
            <td>
                处理陷阱</br>
                做系统调用</br>
                从陷阱返回</br>
            </td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>
                从内核栈恢复寄存器</br>
                转向用户模式</br>
                跳到陷阱之后的程序计数器</br>
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td>
                ....从main返回</br>
                陷入(通过exit())</br>
            </td>
        </tr>
        <tr>
            <td>
                释放进程的内</br>
                将进程列表清除</br>
            </td>
            <td></td>
            <td></td>
        </tr>
    </tbody>
</table>  

:question:***OS怎么获取cpu的控制权***     
:key:     
* 协作方式:   
&nbsp;&nbsp;&nbsp;a. 等待程序做系统调用。  
&nbsp;&nbsp;&nbsp;b. 程序做非法操作。  
* 非协作方式:  
&nbsp;&nbsp;&nbsp;a. 中断。[^2] 

:question:***上下文切换是什么***     
:key:  操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。

:question:***受限直接执行协议（时钟中断）***        
:key: [^3]  
<table>
    <thead>
        <tr>
            <th>操作系统@启动(内核模式)</th>
            <th>硬件</th>
            <th></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>初始化陷阱表</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>
                记住一下地址:<br />
                &nbsp;&nbsp;系统调用处理程序<br />
                &nbsp;&nbsp;时钟处理程序<br />
            </td>
            <td></td>
        </tr>
        <tr>
            <td>启动中断时钟</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>
                启动时钟</br>
                每隔 x ms中断CPU</br>
            </td>
            <td></td>
        </tr>
        <tr>
            <td>操作系统@运行（内核模式）</td>
            <td>硬件</td>
            <td>程序（应用模式）</td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td>进程A.....</td>
        </tr>
        <tr>
            <td></td>
            <td>
                时钟中断<br />
                将寄存器（A）保存到内核栈（A）<br />
                转向内核模式<br />
                跳到陷阱处理程序<br />
            </td>
            <td></td>
        </tr>
        <tr>
            <td>
                处理陷阱<br />
                调用switch()例程<br />
                &nbsp;&nbsp;将寄存器（A）保存到进程结构（A） <br />
                &nbsp;&nbsp;将进程结构（B）恢复到寄存器（B）<br />
                从陷阱返回（进入B）<br />
            </td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>
                从内核栈（B）恢复寄存器（B）<br />
                跳转到用户模式<br />
                跳转到B的程序计数器<br />
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td>进程B.....</td>
        </tr>
    </tbody>
</table>  

[^1]: LDE协议有两个阶段。第一个阶段（在系统引导时），内核初始化陷阱表，并且CPU记住它的位置以供随后使用。内核通过特权指令来执行此操作（所有特权指令均以粗体突出显示）。第二个阶段（运行进程时），在使用从陷阱返回指令开始执行进程之前，内核设置了一些内容（例如，在进程列表中分配一个节点，分配内存）。这会将CPU切换到用户模式并开始运行该进程。当进程希望发出系统调用时，它会重新陷入操作系统，然后再次通过从陷阱返回，将控制权还给进程。该进程然后完成它的工作，并从main()返回。这通常会返回到一些存根代码，它将正确退出该程序（例如，通过调用exit()系统调用，这将陷入OS中）。此时，OS清理干净，任务完成了

[^2]: 时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得CPU的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。

[^3]: 在这个例子中，进程A正在运行，然后被中断时钟中断。硬件保存它的寄存器（在内核栈中），并进入内核（切换到内核模式）。在时钟中断处理程序中，操作系统决定从正在运行的进程A切换到进程B。此时，它调用switch()例程，该例程仔细保存当前寄存器的值（保存到A的进程结构），恢复寄存器进程B（从它的进程结构），然后切换上下文（switch context），具体来说是通过改变栈指针来使用B的内核栈（而不是A的）。最后，操作系统从陷阱返回，恢复B的寄存器并开始运行它。请注意，在此协议中，有两种类型的寄存器保存/恢复。第一种是发生时钟中断的时候。在这种情况下，运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈。第二种是当操作系统决定从A切换到B。在这种情况下，内核寄存器被软件（即OS）明确地保存，但这次被存储在该进程的进程结构的内存中。后一个操作让系统从好像刚刚由A陷入内核，变成好像刚刚由B陷入内核。